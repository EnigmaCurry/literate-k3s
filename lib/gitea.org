
* Gitea

 [[https://gitea.io/][Gitea]] is a self-hosted git platform, much like GitHub. You will need a git
 platform to store your cluster config repository, which Flux will use to keep
 your cluster in sync. Storing this inside the cluster makes logical sense.
 In addition to running gitea repositories inside your cluster, you can also
 easily mirror these repositories to external hosts like GitHub.

 [[https://www.postgresql.org/][Postgresql]] will serve the backend database for Gitea.

** GITEA_DOMAIN
#+name: GITEA_DOMAIN
#+begin_src config :noweb yes :eval no
git.<<CLUSTER>>
#+end_src
** GITEA_POSTGRES_PVC_SIZE
The size of the postgres database volume for gitea:
#+name: GITEA_POSTGRES_PVC_SIZE
#+begin_src config :noweb yes :eval no
5Gi
#+end_src
** GITEA_PVC_SIZE
The size of the data volume for gitea:
#+name: GITEA_PVC_SIZE
#+begin_src config :noweb yes :eval no
5Gi
#+end_src
** GITEA_USER
=GITEA_USER= is the admin account name to create. Note: =admin= is a reserved
name.
#+name: GITEA_USER
#+begin_src config :noweb yes :eval no
root
#+end_src
** GITEA_EMAIL
=GITEA_EMAIL= is the admin account email address:
#+name: GITEA_EMAIL
#+begin_src config :noweb yes :eval no
root@example.com
#+end_src
** Create directory
Create the gitea deployment directory underneath the namespace directory:

#+begin_src shell :noweb yes :eval never-export :exports code
mkdir -p <<SRC_DIR>>/git-system/gitea/
#+end_src

** Create Gitea Secrets
 As initial setup, you must create the Sealed Secret, containing the Gitea
 configuration file, the database password, and other Gitea application specific
 tokens/secrets. The database password is generated randomly via =openssl rand=
 on your local workstation. For the Gitea specific secrets, they need to be
 generated by the gitea command line tool, which can be invoked in temporary
 containers on the cluster, via =kubectl=. These secrets are stored in temporary
 BASH variables: =POSTGRES_PASSWORD=, =INTERNAL_TOKEN=, =SECRET_KEY=, and
 =JWT_SECRET=. A temporary, plain text, config file is created using these
 values. Finally, a Secret is created containing the config file, is sealed
 (encrypted), and the temporary plain text config is deleted.

 The Sealed Secret is encrypted on your cluster, using a key that only your
 cluster has access to, so it is safe to commit the sealed secret along with your
 other manifest files, inside your git repostiory.

 NOTE: this script is a little finnicky: it fails about 1 in 3 times, but you can
 safely run it again if it fails. (Fresh passwords are generated each time.)
 Check the results, and ensure the script finishes completely, and that the file
 =git-system/gitea.sealed_secret.yaml= is created.

 #+begin_src shell :noweb yes :eval never-export :exports code :results output
 set -e
 rm -f git-system/gitea.sealed_secret.yaml
 POSTGRES_USER=gitea
 ## Generate passwords and tokens:
 echo "Generating passwords and tokens"
 POSTGRES_PASSWORD=$(openssl rand --base64 24)
 echo "Generating INTERNAL_TOKEN ..."
 INTERNAL_TOKEN=$(<<kubectl>> \
    run -i --quiet --rm gen-passwd-${RANDOM} \
    --image=gitea/gitea:latest --restart=Never -- \
    gitea generate secret INTERNAL_TOKEN)
 echo "Succesfully created INTERNAL_TOKEN."
 echo "Generating SECRET_KEY ..."
 SECRET_KEY=$(<<kubctl>> \
    run -i --quiet --rm gen-passwd-${RANDOM} \
    --image=gitea/gitea:latest --restart=Never -- \
    gitea generate secret SECRET_KEY)
 echo "Succesfully created SECRET_KEY."
 echo "Generating JWT_SECRET ..."
 JWT_SECRET=$(<<kubectl>> \
    run -i --quiet --rm gen-passwd-${RANDOM} \
    --image=gitea/gitea:latest --restart=Never -- \
    gitea generate secret JWT_SECRET)
 echo "Succesfully created JWT_SECRET."
 CONFIG_TMP=$(mktemp)
 echo "Creating temporary plain text config: ${CONFIG_TMP}"
 cat <<EOF > $CONFIG_TMP
 APP_NAME = <<GITEA_DOMAIN>>

 [server]
 DOMAIN = <<GITEA_DOMAIN>>
 ROOT_URL = https://<<GITEA_DOMAIN>>
 SSH_DOMAIN = <<GITEA_DOMAIN>>
 SSH_PORT = 2222
 START_SSH_SERVER = true

 [service]
 DISABLE_REGISTRATION = true
 REQUIRE_SIGNIN_VIEW = true

 [database]
 DB_TYPE = postgres
 NAME = ${POSTGRES_USER}
 HOST = gitea-postgres
 PASSWD = ${POSTGRES_PASSWORD}
 USER = ${POSTGRES_USER}

 [security]
 INSTALL_LOCK = true
 SECRET_KEY = ${SECRET_KEY}
 INTERNAL_TOKEN = ${INTERNAL_TOKEN}
 DISABLE_GIT_HOOKS = false

 [oauth2]
 JWT_SECRET = ${JWT_SECRET}

 [repository]
 DEFAULT_PRIVATE = private

 EOF
 <<kubectl>> \
    create secret generic gitea \
    --namespace git-system --dry-run=client -o json \
    --from-literal=POSTGRES_USER=$POSTGRES_USER \
    --from-literal=POSTGRES_PASSWORD=$POSTGRES_PASSWORD \
    --from-literal=INTERNAL_TOKEN=$INTERNAL_TOKEN \
    --from-literal=JWT_SECRET=$JWT_SECRET \
    --from-literal=SECRET_KEY=$SECRET_KEY \
    --from-file=app.ini=${CONFIG_TMP} | kubeseal -o yaml > \
  git-system/gitea.sealed_secret.yaml
 rm ${CONFIG_TMP}
 echo "Gitea Sealed Secret created: git-system/gitea/sealed_secret.yaml"
 echo "Removed tempoary config file: ${CONFIG_TMP}"
 echo "Finished!"
 #+end_src

 If the script completes succesfully, you should see the message =Finished!= at
 the bottom of the result above, and =git-system/gitea/sealed_secret.yaml= should
 now exist. If you don't see =Finished!=, then run it again, it should work if
 you try it again...
** Deploy Gitea
    Tangle all the files, =C-c C-v t= then run:

  #+begin_src shell :noweb yes :eval never-export :exports both
  <<kubectl>> apply -k git-system
  #+end_src
** Create Admin account
In order to login, you need to manually create the initial admin account via
=kubectl=, afterward you can add more accounts via the web interface.

#+begin_src shell :noweb yes :eval never-export :exports code :results output
GITEA_ADMIN_PASSWORD=$(openssl rand --base64 24)
TMP_PASSWORD=$(mktemp --suffix .txt)
echo ${GITEA_ADMIN_PASSWORD} > ${TMP_PASSWORD}
echo "Gitea user <<GITEA_USER>> password written to ${TMP_PASSWORD}"
<<kubectl>> -n git-system exec statefulset/gitea -i -- gitea admin user create \
    --username <<GITEA_USER>> --password ${GITEA_ADMIN_PASSWORD} --admin \
    --email <<GITEA_EMAIL>> 
echo "Run: cat ${TMP_PASSWORD}"
#+end_src

Find the password written to the temporary file.

Now you can login to your domain at =https://git.<<CLUSTER>>= (eg.
http://git.k3s.example.com)
** Create test repository
    1. Go to your gitea user profile, and find the =SSH/GPG Keys= section.
    2. Add your local workstation public SSH Key (from
       =${HOME}/.ssh/id_rsa.pub=, use =ssh-keygen= if you haven't got one yet.)
    3. Create a new repository using the =+= icon in the upper right corner,
       name it =test1=.
    4. From the repository page, find the =SSH= clone URL. (Should look like
       this: =ssh://git@git.k3s.example.com:2222/root/test1.git=)
    5. Test cloning it someplace: =git clone
       ssh://git@git.k3s.example.com:2222/root/test1.git=

Assuming that's working, Traefik is providing Gitea SSH ingress (TCP not HTTP)
on port 2222. That's neat! Port 2222 is connected to the gitea container,
through traefik, not to your host SSH daemon (which still runs on regular port
22).
** Mirror repositories to GitHub or elsewhere
You can mirror your gitea repositories to another git host, like GitHub. This
has to be setup separately for each repository you wish to mirror.

Create a new SSH keypair (separate from your user account!) to use as a deploy
key:
#+begin_src shell :noweb yes :eval never-export :exports code :results output
SSH_KEY_TMP=$(mktemp -u --suffix .key)
ssh-keygen -C gitea-mirror-$RANDOM -P '' -f ${SSH_KEY_TMP} 2>&1 > /dev/null
echo "Public SSH Key written to ${SSH_KEY_TMP}.pub"
echo "Private SSH Key written to ${SSH_KEY_TMP}"
#+end_src

#+RESULTS:
: Public SSH Key written to /tmp/tmp.gYZkhiUqqD.key.pub
: Private SSH Key written to /tmp/tmp.gYZkhiUqqD.key

Create a new repository on GitHub. Go to the Settings, then Deploy keys and
create a new deploy key, and paste the public key from the file generated
(=/tmp/tmp.#####.key.pub=).

Next you need to create a git hook that pushes to github whenever a gitea
repository receives a push. Go to the gitea repository settings, go to Git
Hooks, edit the hook called post-receive and enter this script:

#+begin_example
#!/bin/bash
## Set the full git SSH URL for the mirror repository:
MIRROR_REPO="git@github.com:GITHUB_USERNAME/GITHUB_REPO_NAME.git"
KNOWNHOSTS=$(mktemp)

## Public known ssh key for github:
cat <<'EOF' > ${KNOWNHOSTS}
github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
EOF

## Private ssh deploy key for remote mirror:
KEYFILE=$(mktemp)
cat <<'EOF' > ${KEYFILE}
-----BEGIN OPENSSH PRIVATE KEY-----
  YOUR DEPLOY KEY GOES HERE
-----END OPENSSH PRIVATE KEY-----
EOF

## Push changes to mirror using deploy key and known hosts file:
GIT_SSH_COMMAND="/usr/bin/ssh -i ${KEYFILE} -o UserKnownHostsFile=${KNOWNHOSTS}" git push --mirror ${MIRROR_REPO}
rm ${KNOWNHOSTS}
rm ${KEYFILE}
#+end_example

Edit the =MIRROR_REPO= at the top for your repository. Replace the placeholder
for the deployment key, with the one generated in the private key file
(=/tmp/tmp.#####.key=). Save the hook.

Now when you push to this repository it should automatically push to the remote
mirror as well.
** git-system/gitea/kustomization.yaml
=kustomization.yaml= lists all of the =git-system= namespace manifests:
#+begin_src yaml :noweb yes :eval no :tangle git-system/gitea/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- sealed_secret.yaml
- pvc.yaml
- database.yaml
- statefulset.yaml
- ingress.yaml
#+end_src
** git-system/gitea/pvc.yaml
     #+begin_src yaml :noweb yes :eval no :tangle git-system/gitea/pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: gitea-postgres-data
  namespace: git-system
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <<GITEA_POSTGRES_PVC_SIZE>>
  storageClassName: local-path
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: gitea-data
  namespace: git-system
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <<GITEA_PVC_SIZE>>
  storageClassName: local-path

     #+end_src
** git-system/gitea/database.yaml
      #+begin_src yaml :noweb yes :eval no :tangle git-system/gitea/database.yaml
apiVersion: v1
kind: Service
metadata:
  name: gitea-postgres
  namespace: git-system
spec:
  selector:
    app: gitea-postgres
  type: ClusterIP
  ports:
    - port: 5432
      targetPort: 5432
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: gitea-postgres
  namespace: git-system
spec:
  selector:
    matchLabels:
      app: gitea-postgres
  serviceName: gitea-postgres
  replicas: 1
  template:
    metadata:
      labels:
        app: gitea-postgres
    spec:
      containers:
        - name: gitea-postgres
          image: postgres
          volumeMounts:
            - name: gitea-postgres-data
              mountPath: /var/lib/postgresql/data
          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: gitea
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: gitea
                  key: POSTGRES_PASSWORD
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
      volumes:
        - name: gitea-postgres-data
          persistentVolumeClaim:
            claimName: gitea-postgres-data

      #+end_src
** git-system/gitea/statefulset.yaml
#+begin_src yaml :noweb yes :eval no :tangle git-system/gitea/statefulset.yaml
apiVersion: v1
kind: Service
metadata:
  name: gitea-web
  namespace: git-system
spec:
  ports:
  - name: web
    port: 80
    protocol: TCP
    targetPort: 3000
  selector:
    app: gitea
---
apiVersion: v1
kind: Service
metadata:
  name: gitea-ssh
  namespace: git-system
spec:
  ports:
  - name: ssh
    port: 2222
    targetPort: 2222
    protocol: TCP
  selector:
    app: gitea
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: gitea
  name: gitea
  namespace: git-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gitea
  serviceName: gitea-web
  template:
    metadata:
      labels:
        app: gitea
    spec:
      containers:
      - image: gitea/gitea:latest
        name: gitea
        ## debug:
        ## command: ["/bin/sh", "-c", "sleep 99999999999"]
        volumeMounts:
          - name: data
            mountPath: /data
          - name: config
            mountPath: /data/gitea/conf
        ports:
        - containerPort: 3000
          name: web
        - containerPort: 2222
          name: ssh
        env:
          - name: INSTALL_LOCK
            value: "true"
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: gitea-data
        - name: config
          secret:
            secretName: gitea

#+end_src
** git-system/gitea/ingress.yaml
      #+begin_src yaml :noweb yes :eval no :tangle git-system/gitea/ingress.yaml
apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: gitea-ssh
  namespace: git-system

spec:
  weighted:
    services:
      - name: gitea-ssh
        weight: 1
        port: 2222

---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: gitea-web
  namespace: git-system
spec:
  entryPoints:
  - websecure
  routes:
  - kind: Rule
    match: Host(`<<GITEA_DOMAIN>>`)
    services:
    - name: gitea-web
      port: 80
  tls:
    certResolver: default
---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRouteTCP
metadata:
  name: gitea-ssh
  namespace: git-system
spec:
  entryPoints:
  - ssh
  routes:
  - kind: Rule
    ## Domain matching is not possible with SSH, so match all domains:
    match: HostSNI(`*`)
    services:
    - name: gitea-ssh
      port: 2222

      #+end_src

* git-system/kustomization.yaml
#+begin_src yaml :noweb yes :eval no :tangle git-system/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- namespace.yaml
#+end_src
* git-system/namespace.yaml
=namespace.yaml= creates the =git-system= namespace:
#+begin_src yaml :noweb yes :eval no :tangle git-system/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: git-system
#+end_src
