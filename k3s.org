#+title: Literate K3s Cluster
#+author: EnigmaCurry
#+OPTIONS: ^:{}
#+EXPORT_FILE_NAME: index.html
#+INCLUDE: "./meta/export-html.org"
#+INCLUDE: "./meta/github-ribbon.org"
#+INCLUDE: "./meta/intro.org"

* Core Config
** Specify the core config file
   Core config is intended to be loaded [[attachment:config.org][config.org]] by default, but you can
   specify a different file instead. You need to set an Emacs variable in your
   Emacs config file (Make sure to replace =k3s.example.com= with your actual
   =<<CLUSTER>>== domain name, on /both lines/):

#+begin_example
(setq literate-k3s-default-config-file-k3s.example.com "~/git/literate-k3s/override.org")
(org-babel-lob-ingest literate-k3s-default-config-file-k3s.example.com)
#+end_example

 =~/git/literate-k3s/override.org= is the absolute path of the new config file.

** CLUSTER
  =CLUSTER= is the domain name of your cluster:
  #+begin_src config :noweb yes :eval no
  <<CLUSTER>>
  #+end_src
** CLUSTER_SSH_USER
   =CLUSTER_SSH_USER= is the admin SSH account of the cluster.
   #+begin_src config :noweb yes :eval no
   <<CLUSTER_SSH_USER>>
   #+end_src
** KUBE_CONFIG
  =KUBE_CONFIG= is the local path to the kubectl config file
  #+begin_src config :noweb yes :eval no
  <<KUBE_CONFIG>>
  #+end_src
** kubectl command
 Since you'll need to specify the kubectl config file each and every time you use
 =kubectl=, let's create a NoWeb alias for it (=<<kubectl>>=), to use in other
 code blocks.
 #+begin_src config :noweb yes :eval no
 <<kubectl>>
 #+end_src

* kube-system
=kube-system= is the namespace for running system wide features, mostly network
related. 
#+INCLUDE: "./traefik.org"
#+INCLUDE: "./sealed_secrets.org"
* git-system
=git-system= is the namespace created for Gitea.
#+INCLUDE: "./gitea.org"
* flux-system
#+INCLUDE: "./flux.org"
* LICENSE
#+INCLUDE: "./LICENSE.org"
* Footnotes

This should be the very last section in this document. It is excluded from the
HTML export. This section contains code that will run when Emacs loads this
file. When Emacs loads a file, it searches for the =Local Variables= comment at
the very bottom of the file, and loads variables defined there and runs any
=eval= code listed.

Here is the startup code block that =Local Variables= references:

#+name: k3s-org-emacs-load
#+begin_src elisp :noweb yes :eval never-export :results none
<<literate-k3s-load-core-config>>
<<literate-k3s-reload-config-before-tangle>>
<<enable-export-on-save>>
<<export-html-with-useful-ids>>
#+end_src

Here is code to load the core config file:
#+name: literate-k3s-load-core-config
#+begin_src elisp :noweb yes :exports code :eval never-export :results none
  (if (boundp 'literate-k3s-default-config-file-<<CLUSTER>>)
      (org-babel-lob-ingest literate-k3s-default-config-file-<<CLUSTER>>)
    (org-babel-lob-ingest "config.org"))
#+end_src

Here is code to reload config.org before tangling and to automatically export
HTML whenever this file is saved:

#+name: literate-k3s-reload-config-before-tangle
#+begin_src elisp :noweb yes :exports code :eval never-export :results none
  (if (not(boundp 'literate-k3s-default-config-file-<<CLUSTER>>))
    (setq literate-k3s-default-config-file-<<CLUSTER>> "config.org"))
  (setq literate-k3s-buffer-<<CLUSTER>> (current-buffer))
  (defun literate-k3s-reload-config ()
    (org-babel-lob-ingest (buffer-file-name literate-k3s-buffer-<<CLUSTER>>))
    (org-babel-lob-ingest literate-k3s-default-config-file-<<CLUSTER>>))
  (literate-k3s-reload-config)

  (if (boundp 'literate-k3s-watch-dirs)
      (progn
        (add-to-list 'literate-k3s-watch-dirs default-directory)
        (add-to-list 'literate-k3s-watch-dirs (concat default-directory "meta/"))
        )
    (setq literate-k3s-watch-dirs
          (list default-directory (concat default-directory "meta/"))))

  (add-hook 'after-save-hook
            (lambda ()
              (when (and (member default-directory literate-k3s-watch-dirs)
                         (eq major-mode 'org-mode))
                (literate-k3s-reload-config)
                (with-current-buffer literate-k3s-buffer-<<CLUSTER>>
                  (org-html-export-to-html)))))
  (add-hook 'org-babel-pre-tangle-hook
            (lambda ()
              (when (and (member default-directory literate-k3s-watch-dirs)
                         (eq major-mode 'org-mode))
                (literate-k3s-reload-config))))
#+end_src

Here is a fix so that Org exports proper HTML anchors rather than the random
IDs it generally provides:

#+name: export-html-with-useful-ids
#+begin_src elisp :eval never-export
  ;; org-mode export useful anchors:
  ;; thank you https://github.com/alphapapa/unpackaged.el
  ;; This code is licensed GNU GPL v3 and copied verbatim from upstream:
  (define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
    "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
    :global t
    (if unpackaged/org-export-html-with-useful-ids-mode
        (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
      (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))

  (defun unpackaged/org-export-get-reference (datum info)
    "Like `org-export-get-reference', except uses heading titles instead of random numbers."
    (let ((cache (plist-get info :internal-references)))
      (or (car (rassq datum cache))
          (let* ((crossrefs (plist-get info :crossrefs))
                 (cells (org-export-search-cells datum))
                 ;; Preserve any pre-existing association between
                 ;; a search cell and a reference, i.e., when some
                 ;; previously published document referenced a location
                 ;; within current file (see
                 ;; `org-publish-resolve-external-link').
                 ;;
                 ;; However, there is no guarantee that search cells are
                 ;; unique, e.g., there might be duplicate custom ID or
                 ;; two headings with the same title in the file.
                 ;;
                 ;; As a consequence, before re-using any reference to
                 ;; an element or object, we check that it doesn't refer
                 ;; to a previous element or object.
                 (new (or (cl-some
                           (lambda (cell)
                             (let ((stored (cdr (assoc cell crossrefs))))
                               (when stored
                                 (let ((old (org-export-format-reference stored)))
                                   (and (not (assoc old cache)) stored)))))
                           cells)
                          (when (org-element-property :raw-value datum)
                            ;; Heading with a title
                            (unpackaged/org-export-new-title-reference datum cache))
                          ;; NOTE: This probably breaks some Org Export
                          ;; feature, but if it does what I need, fine.
                          (org-export-format-reference
                           (org-export-new-reference cache))))
                 (reference-string new))
            ;; Cache contains both data already associated to
            ;; a reference and in-use internal references, so as to make
            ;; unique references.
            (dolist (cell cells) (push (cons cell new) cache))
            ;; Retain a direct association between reference string and
            ;; DATUM since (1) not every object or element can be given
            ;; a search cell (2) it permits quick lookup.
            (push (cons reference-string datum) cache)
            (plist-put info :internal-references cache)
            reference-string))))

  (defun unpackaged/org-export-new-title-reference (datum cache)
    "Return new reference for DATUM that is unique in CACHE."
    (cl-macrolet ((inc-suffixf (place)
                               `(progn
                                  (string-match (rx bos
                                                    (minimal-match (group (1+ anything)))
                                                    (optional "--" (group (1+ digit)))
                                                    eos)
                                                ,place)
                                  ;; HACK: `s1' instead of a gensym.
                                  (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                             (match-string 2 ,place)))
                                          (suffix (if suffix
                                                      (string-to-number suffix)
                                                    0)))
                                    (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
      (let* ((title (org-element-property :raw-value datum))
             (ref (url-hexify-string (substring-no-properties title)))
             (parent (org-element-property :parent datum)))
        (while (--any (equal ref (car it))
                      cache)
          ;; Title not unique: make it so.
          (if parent
              ;; Append ancestor title.
              (setf title (concat (org-element-property :raw-value parent)
                                  "--" title)
                    ref (url-hexify-string (substring-no-properties title))
                    parent (org-element-property :parent parent))
            ;; No more ancestors: add and increment a number.
            (inc-suffixf ref)))
        ref)))
(unpackaged/org-export-html-with-useful-ids-mode)
#+end_src


Keep this at the very bottom of the file:

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "k3s-org-emacs-load") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:





